def func_2(n, k, dp):
    if (k == 0) :
        return 0
        #The program returns 0, indicating that with k being 0, no different digits are allowed in the number.
    #State of the program after the if block has been executed: *`n` is a non-negative integer representing a number, `k` is a non-negative integer indicating the maximum number of different digits allowed in the number, `dp` is a dictionary used for memoization that maps tuples of (n, k) to integer results. `k` is greater than 0.
    if ((n, k) in dp) :
        return dp[n, k]
        #The program returns the memoized result for the tuple (n, k) from the dictionary dp, where n is a non-negative integer and k is a non-negative integer indicating the maximum number of different digits allowed, and k is greater than 0.
    #State of the program after the if block has been executed: *`n` is a non-negative integer representing a number, `k` is a non-negative integer indicating the maximum number of different digits allowed in the number, `dp` is a dictionary used for memoization that maps tuples of (n, k) to integer results. `k` is greater than 0, and the tuple `(n, k)` is not in `dp`.
    if (n < 10 ** k) :
        dp[n, k] = n
    else :
        dp[n, k] = 9
        for i in range(1, k):
            dp[n, k] += 9 * 10 ** (i - 1) * (10 ** (k - i) - 10 ** (i - 1))
            
        #State of the program after the  for loop has been executed: `n` is a non-negative integer, `k` is greater than 1, `dp[n, k]` is equal to the cumulative total from all iterations, which is dependent on `k`.
        dp[n, k] += (10 ** (k - 1) - 10 ** (k - 2)) * (n // 10 ** (k - 1) - 1)
        dp[n, k] %= MOD
    #State of the program after the if-else block has been executed: *`n` is a non-negative integer, `k` is a non-negative integer greater than 0, and the tuple `(n, k)` is not in `dp`. If `n` is less than 10 raised to the power of `k`, then `dp` is updated to contain the entry `(n, k): n`. Otherwise, `dp[n, k]` is updated to `dp[n, k] % MOD`, where `k` is greater than 1.
    return dp[n, k]
    #The program returns the value of dp[n, k], which is either updated to n if n is less than 10 raised to the power of k, or dp[n, k] % MOD if k is greater than 1.
#Overall this is what the function does: The function accepts parameters n (a non-negative integer), k (a non-negative integer indicating the maximum number of different digits allowed), and dp (a dictionary for memoization). It returns 0 if k is 0; if k > 0 and (n, k) is in dp, it returns the memoized result; otherwise, it updates and returns the computed value based on the conditions involving n and k.
Case_1: The program returns 0, indicating that with k being 0, no different digits are allowed in the number.

Case_2: The program returns the memoized result for the tuple (n, k) from the dictionary dp, where n is a non-negative integer and k is a non-negative integer indicating the maximum number of different digits allowed, and k is greater than 0.

Case_3: The program returns the value of dp[n, k], which is either updated to n if n is less than 10 raised to the power of k, or dp[n, k] % MOD if k is greater than 1.

