
You have been assigned the role of a program verifier. Your task is to determineg the correctness of a given Python program based on the provided problem description . If the program is correct, that is it meets the requirements in the problem description, print "True"; otherwise, print "False". You need to strictly follow the format Correctness: **True or False**.

# Your task:
I am now giing you the problem description. This is what the function must do.
PROBLEM DESCRIPTION: You are given two integers $l$ and $r$ ($l \\le r$). Your task is to calculate the sum of numbers from $l$ to $r$ (including $l$ and $r$) such that each number contains at most $k$ different digits, and print this sum modulo $998244353$.\n\nFor example, if $k = 1$ then you have to calculate all numbers from $l$ to $r$ such that each number is formed using only one digit. For $l = 10, r = 50$ the answer is $11 + 22 + 33 + 44 = 110$.\n\n\n-----Input-----\n\nThe only line of the input contains three integers $l$, $r$ and $k$ ($1 \\le l \\le r < 10^{18}, 1 \\le k \\le 10$) — the borders of the segment and the maximum number of different digits.\n\n\n-----Output-----\n\nPrint one integer — the sum of numbers from $l$ to $r$ such that each number contains at most $k$ different digits, modulo $998244353$.\n\n\n-----Examples-----\nInput\n10 50 2\n\nOutput\n1230\n\nInput\n1 2345 10\n\nOutput\n2750685\n\nInput\n101 154 2\n\nOutput\n2189\n\n\n\n-----Note-----\n\nFor the first example the answer is just the sum of numbers from $l$ to $r$ which equals to $\\frac{50 \\cdot 51}{2} - \\frac{9 \\cdot 10}{2} = 1230$. This example also explained in the problem statement but for $k = 1$.\n\nFor the second example the answer is just the sum of numbers from $l$ to $r$ which equals to $\\frac{2345 \\cdot 2346}{2} = 2750685$.\n\nFor the third example the answer is $101 + 110 + 111 + 112 + 113 + 114 + 115 + 116 + 117 + 118 + 119 + 121 + 122 + 131 + 133 + 141 + 144 + 151 = 2189$.

This was the problem description. Lets move on to the  annotated program. The program must do what the problem description says for it to be correct.

Annotated Program:
```
MOD = 998244353
(l, r, k) = map(int, input().split())

#Function 1:
#State of the program right berfore the function call: l and r are integers such that 1 <= l <= r < 10^18, and k is an integer such that 1 <= k <= 10.
def func_1(l, r, k):
    dp = {}
    return (func_2(r, k, dp) - func_2(l - 1, k, dp)) % MOD
    #The program returns the result of the calculation (func_2(r, k, dp) - func_2(l - 1, k, dp)) % MOD, where func_2 is a function that takes r, k, and dp as parameters and is evaluated for the given values of l and r, with k and dp also being defined.

#Function 2:
#State of the program right berfore the function call: n is a non-negative integer less than \(10^{18}\), k is a positive integer such that 1 <= k <= 10, and dp is a dictionary that maps tuples of (n, k) to integers.
def func_2(n, k, dp):
    if (k == 0) :
        return 0
        #The program returns 0
    #State of the program after the if block has been executed: *`n` is a non-negative integer less than \(10^{18}\), `k` is a positive integer such that 1 <= `k` <= 10, `k` is greater than 0, and `dp` is a dictionary that maps tuples of (n, k) to integers.
    if ((n, k) in dp) :
        return dp[n, k]
        #The program returns the value associated with the tuple (n, k) from the dictionary `dp`, where `n` is a non-negative integer less than \(10^{18}\) and `k` is a positive integer between 1 and 10.
    #State of the program after the if block has been executed: *`n` is a non-negative integer less than \(10^{18}\), `k` is a positive integer such that 1 <= `k` <= 10, `k` is greater than 0, `dp` is a dictionary that maps tuples of (n, k) to integers, and the tuple (n, k) is not in the dictionary `dp`.
    if (n < 10 ** k) :
        dp[n, k] = n
    else :
        dp[n, k] = 9
        for i in range(1, k):
            dp[n, k] += 9 * 10 ** (i - 1) * (10 ** (k - i) - 10 ** (i - 1))
            
        #State of the program after the  for loop has been executed: `n` is a non-negative integer less than \(10^{18}\), `k` is a positive integer greater than or equal to `2`, `dp[n, k]` is now the final computed value after `k-1` iterations based on the defined formula.
        dp[n, k] += (10 ** (k - 1) - 10 ** (k - 2)) * (n // 10 ** (k - 1) - 1)
        dp[n, k] %= MOD
    #State of the program after the if-else block has been executed: *`n` is a non-negative integer less than \(10^{18}\) and `k` is a positive integer such that 1 <= `k` <= 10. If `n` is less than \(10^{k}\), then `dp` now contains the key `(n, k)` mapped to the value `n`. If `k` is greater than or equal to 2, then `dp[n, k]` is updated to `dp[n, k] % MOD`.
    return dp[n, k]
    #The program returns the value mapped to the key (n, k) in the dictionary dp, where n is a non-negative integer less than \(10^{18}\) and k is a positive integer such that 1 <= k <= 10. If n is less than \(10^{k}\), then dp[n, k] is equal to n. If k is greater than or equal to 2, then dp[n, k] is updated to dp[n, k] % MOD.


```
The program is correct only if it meets the problem description! The problem description is defined before the program.  Return Correctness: **True** if the program follows the problem description, otherwise return Correctness: **False** if the program does not do what the problem description asks for for every potential case.
If the program is correct explain why it always does what the problem description say. If it is incorrect explain why it does not do what the problem description says or a case where it doesnot follow the problem description.
