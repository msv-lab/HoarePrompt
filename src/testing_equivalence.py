import re



# This script's responsible for executing small code snippets and determining the resulting program state based on the provided initial state and program code. It is the general script for a simple program statement (not loops or ifs, try etc)
semantic_comparison_prompt = """
Given the following two postconditions for a Python function:

1. Expected Postcondition: A description of the state of the program that should hold after executing the given code.
2. Computed Postcondition: A description of the state of the program generated by a tool based on the provided precondition and code.

Your task is to determine whether these two postconditions are semantically relatively the same, meaning they describe a very similar logical program state or behavior. You do not need to check for exact wording, but their semantic meaning must align.

For your response, provide:

- SAME: **True or False** (True if they describe the same state semantically; False if not).
- REASON: **The reason why the postconditions are the same or not**.

Here are the two postconditions:

Expected Postcondition:  
{expected_postcondition}

Computed Postcondition:  
{computed_postcondition}

Your Response: 

SAME: **True or False**  
REASON: **Explanation for the decision**
"""

import re

def extract_result(s: str, keyword: str) -> str:
    # Define a pattern to match with or without stars
    pattern = fr"{keyword}:\s*(\*\*(.*?)\*\*|.*)"
    matches = re.findall(pattern, s, re.DOTALL)
    
    if matches:
        # Extract the relevant match group depending on whether stars are present
        # If stars are present, group[1] is the content; otherwise, it's group[0]
        res = matches[-1][1] if matches[-1][0].startswith("**") else matches[-1][0]
        
        # Clean up the result: remove any stars, leading/trailing whitespace
        return res.strip("*").strip()
    
    return s


# This is the main function, it completes the prompt, queries the model and extracts the result, meaining the output state of that program part
def assess_postcondition_equivalence(expected_postcondition, computed_postcondition, model):
   
    prompt = semantic_comparison_prompt.format(expected_postcondition=expected_postcondition, computed_postcondition=computed_postcondition)
    response = model.query(prompt)
    print(response)
    post = extract_result(response, "SAME")
    reason= extract_result(response, "REASON")
    print("*" * 50)
    print(f"LLM Reply: {post}")

    if 'true' in post.lower().strip() :
        return True , reason
    if "false" in post.lower().strip() :
        return False , reason
    return post , reason





